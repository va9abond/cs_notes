___
## Почему нельзя выносить реализацию шаблонных методов класса в отдельный файл?

[Ответ 1](https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file)
[Ответ 2]()

Пусть существует параметрический класс `Object`

File: Object.h
```cpp
template<class Type> Object {
public:

	Object();
	
	Object(const Type &value) {
		_value = value;	
	}

	~Object();

	void move();
	
protected:
Type &_value;
}
```
File: Object.cpp
```cpp
template<class Type> Object<Type>::Object() {
	_value = std::rand();
}
template<class Type> Object<Type>::~Object() = default;

template<class Type> void Object<Type>::move() {
/* code of implementation */
} 
```
File: Source.cpp
```cpp
int main() {
	Object<int> object;
	
return 0;
}
```

Во время выполнения программы компилятор создает класс `ObjectInt` и пишет для него определние: 
```cpp
class ObjectInt {
public:

	ObjectInt() {
		_value = std::rand();
	}
	ObjectInt(const int &value) {
		_value = value;	
	}

	~ObjectInt() = default;
	
protected:
int &_value;
}
```

Но реализация методов класса `Object` из файла Object.cpp не доступна для класса `ObjectInt`, поэтому для этого класса компилятор не может найти реализацию методов. 
___
## Решение
