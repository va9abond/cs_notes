
# 1 Basics
## 1.2 Programms

- С++ компилируемый язык, т.е. для работы программы исходный код должен быть скомпилирован - переработан в `объектный файл`.
  
  ![[cpp_build.png]]
  
- Выполняемая программа создается под конкретную комбинацию железа и ОС, поэтому один и тот же выполнисый файл нельзя запустить на MacOS и Windows 
- Стандарт ISO C++ определяет два вида сущностей 
	- **Фундаментальные возможности языка** - встроенные типы (*например*, `int`, `char`) или циклы (*например*, `for`, `while`)
	- **Компоненты стандартных библиотек** - контейнеры `vector`, `map` или операции ввода-вывода (*например*, `<<` или `getline()` ). Стандатная библиотека реализуется на самом языке C++ с небольшими вставками машинного кода 
- C++ - **статически типизированный язык**, т.е. тип каждой сущности должен быть известен компилятору в точке использования, т.к. тип объекта определяет набор применимых к нему операций

___
## 1.3 Functions

- Функция не может быть вызвана, если она не объявлена ранее
- **Объявление функции** назначает для нее:
	- тип возвращаемого значения
	- имя
	- количество и типы аргументов
- **Семантика передачи** аргументов в функцию идентична **сементике инициализации**: 
	1. выполняется проверка типов аргументов
	   - при необходимости происходит неявное преобразование типов аргументов 
- **Тип фукнции** включает в себя тип возвращаемого значения и последовательность типов аргументов. Если функция является членом класса (или пространства имен), то имя ее класса тоже включается в тип функции 
  ```cpp
  double get (const std::vector<double> &vector, int index) {} 
  // Тогда тип функции: `double(const std::vector<double>&, int)`
  ```
  
  ```cpp
  char& String::operator[] (int index) {}
  // Тип функции: char& String::(int)
  ```

- Если могут быть вызваны две алтернативные функции одновременно, то вызов любой из них будет считаться неоднозначным, компилятор выдаст ошибку:
  ```cpp
  void print (int, double);
  void print (double, int);
  void user2() {
	  print(0,0); // Ошибка компилятора: UB  
  }
  ```

- При перегрузке функции каждая функция с одним и тем же именем должна реализовывать одну и ту же семантику, т.е. в независимости от аргументов она должна делать примерно одно и тоже(*например*, функции `print()` в зависимости от аргументов будут выводить в консоль разные значения, но тем не менее задача функции остается прежней - вывод информации в консоль)

___
## 1.4 Types, variables and arithmetic 

- Каждое имя или выражение должно иметь тип, который определяет, какие операции могут быть над ними выполнены
- **Объявление** - инструкция, которая вводит объявляемую сущность в программу, оно определяет *тип* этой сущности:
	- **Тип** определяет *множество возможных значений* и *множество операций* для сущности
	- **Объект** - место в памяти, в котором хранится значение некоторого типа 
	- **Значение** - *множество битов*, интерпретируемых в соответствии с типом 
	- **Переменная** - именованный объект
- Каждый фундаментальный тип соответствует аппаратным возможностям и имеет фиксированный размер
	- **Размер типа** - определяет диапазон значений, которые могут храниться в объекте этого типа
```note
1. Размер типа зависит от реализации, т.е. он может меняться от машины r  машине
2. Размер типа на данной машине может быть получен с помощью оператора `sizeof()`
```

- [sizeof()](https://en.cppreference.com/w/cpp/language/sizeof)

- Целочисленные литералы по умолчанию - десятичные(*например,* 42)
	- **0b** - двоичный целочесленный литерал(*например,* 0b10101010)
	- **0x** - целочисленный литерал по основанию 16(*например,* 0xBAD1234)
	- 0  - целочисленный литерал по основанию 8(*например,* 0334)
- Для удобства длинный литерал можно разбить символом `'` 
  (*например,* 3.1415'92653'58979 или 0х3.243F'6А88'85А3'0803)
