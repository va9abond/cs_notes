___
- **sources:**
	- [Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e-error-handling)
	- 

___

Процесс обратки ошибок состоит из: 
1. Обнаружение ошибки
2. Предоставление информации об ошибке ее обработчику
3. Сохранение текущего состояния программы
4. Избежание утечки ресурсов

___
# Erorr handling rules

## E1: Разработайте стратегию обработки ошибок на ранней стадии проектирования 

**Причина.** Последовательную и полную стратегию обработки ошибок и утечек ресурсов сложно внедрить в систему 

___

## E2: Выбрасывайте исключения, чтобы указать, что функция не может выполнить свою задачу

**Причина.** Это нужно, чтобы сделать обработку ошибок систематической, надежной и неповторяющейся

```c++
struct Foo {
    vector<Thing> v;
    File_handle f;
    string s;
};

void use()
{
    Foo bar {{Thing{1}, Thing{2}, Thing{monkey}}, {"my_file", "r"}, "Here we go!"};
    // ...
}
```

Здесь несколько проблем. 
1. Конструкторы классов `vector` и `string` могут быть не в состоянии выделить достаточное количество памяти для своих элементов
2. Конструктор класса `vector` может не смочь скопировать объекты их списка инициализации `{ Thing{1}, Thing{2}, Thing{monkey} }`
3. `File_handle` может быть не в состоянии открыть файл "my_file"

В каждом из перечисленных пунктов конструкторы выбрасывают исключения для их обработки тем объектом, в котором они были вызваны, в нашем случае - функцией `use()`. Если `use()` может справится с ошибкой, чтобы сконструировать объект `bar`, то она может взять управление на себя с помощью блока `try/catch`. В любом случае, перед тем как конструктор структуры `Foo` передает управление тому, кто пытался создать объект этой структуры, он корректно уничтожит сконструированные элементы.

Конструктор класса `File_handle` должен быть определен так:
```c++
File_handle::File_handle(const string& name, const string& mode)
    : f{fopen(name.c_str(), mode.c_str())}
{
    if (!f)
        throw runtime_error{"File_handle: could not open " + name + " as " + mode};
}
```

==**Note**== Не используйте ключевое слово `throw` как альтернативу `return`, чтобы выйти из функции

___

## E3: Используйте исключения только для обработки ошибок

**Причина.** Это отделяет обработку ошибок от "обычного кода". Реализации компиляторов C++, как правило, оптимизируют код в предположении, что исключения встречаются редко

```c++
// don't: exception not used for error handling
int find_index(vector<string>& vec, const string& x)
{
    try {
        for (gsl::index i = 0; i < vec.size(); ++i)
            if (vec[i] == x) throw i;  // found x
    }
    catch (int i) {
        return i;
    }
    return -1;   // not found
}
```

Этот код выполняется медленнее, чем очевидная альтернатива. Нет ничего исключительного в нахождении значения в векторе

___

## E4: ??Разработайте свою стратегию обработки ошибок с учетом инвариантов

**Инвариант** - логическое условие для членов объекта, которое должен установить конструктор, чтобы функции-члены могли правильно использовать этот объект. (Т.е. например, конструктор задает тип члена класса, тогда метод класса будет работать с этим полем объекта, как с контретным полем определенного типа. И тип члена класса не меняется со временем) 

**Причина.** Чтобы использовать объект, он должен находиться в допустимом состоянии (формально или неформально определяемом инвариантом), а для восстановления после ошибки каждый не уничтоженный объект должен находиться в допустимом состоянии.

___

## E3: 

___

## E4:

___

## E3: 

___

## E4:

___

## E3: 

___

## E4:

___

## E3: 

___

## E4:

___

## E3: 

___

## E4:

___


